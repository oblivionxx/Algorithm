/*
Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:

Only one letter can be changed at a time
Each intermediate word must exist in the word list
For example,

Given:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]
Return
  [
    ["hit","hot","dot","dog","cog"],
    ["hit","hot","lot","log","cog"]
  ]
Note:
All words have the same length.
All words contain only lowercase alphabetic characters.

Array, Backtracking, BFS, String
 */
public class LT126_Word_Ladder_II {
	https://leetcode.com/discuss/9523/share-two-similar-java-solution-that-accpted-by-oj
	https://leetcode.com/discuss/44110/super-fast-java-solution-two-end-bfs
	https://leetcode.com/discuss/64808/my-concise-java-solution-based-on-bfs-and-dfs
			
			
	public List<List<String>> findLadders(String beginWord, String endWord, Set<String> wordList) {
        
    }
}
