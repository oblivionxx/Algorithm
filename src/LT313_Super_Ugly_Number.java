import java.util.*;

/*
Write a program to find the nth super ugly number.

Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32] is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of size 4.

Note:
(1) 1 is a super ugly number for any given primes.
(2) The given numbers in primes are in ascending order.
(3) 0 < k ≤ 100, 0 < n ≤ 106, 0 < primes[i] < 1000.

Math, Heap
 */
public class LT313_Super_Ugly_Number {
    // Basic idea is same as ugly number II, new ugly number is generated by
    // multiplying a prime with previous generated ugly number. One catch is
    // need to remove duplicate
    // Let's start with the common solution from ugly number II 36 ms,
    // Theoretically O(kN)

    public int nthSuperUglyNumber(int n, int[] primes) {
	int[] ugly = new int[n];
	int[] idx = new int[primes.length];

	ugly[0] = 1;
	for (int i = 1; i < n; i++) {
	    // new ugly number is generated by multiplying a prime with previous
	    // generated ugly number
	    ugly[i] = Integer.MAX_VALUE;
	    for (int j = 0; j < primes.length; j++)
		ugly[i] = Math.min(ugly[i], primes[j] * ugly[idx[j]]);

	    // slip duplicate. increase the index of primes to build from. eg.
	    // 2*3. 3*2. skip
	    for (int j = 0; j < primes.length; j++) {
		if (ugly[i] == primes[j] * ugly[idx[j]]) {
		    idx[j]++;
		}
	    }
	}

	return ugly[n - 1];
    }

    // If you look at the above solution, it has redundant multiplication can be
    // avoided, and also two for loops can be consolidated into one. This
    // trade-off space for speed. 23 ms, Theoretically O(kN)

    public int nthSuperUglyNumber2(int n, int[] primes) {
	int[] ugly = new int[n];
	int[] idx = new int[primes.length];
	int[] val = new int[primes.length];
	Arrays.fill(val, 1);

	int next = 1;
	for (int i = 0; i < n; i++) {
	    ugly[i] = next;

	    next = Integer.MAX_VALUE;
	    for (int j = 0; j < primes.length; j++) {
		// skip duplicate and avoid extra multiplication
		if (val[j] == ugly[i])
		    val[j] = ugly[idx[j]++] * primes[j];
		// find next ugly number
		next = Math.min(next, val[j]);
	    }
	}

	return ugly[n - 1];
    }

    // Can we do better? Theoretically yes, by keep the one candidates for each
    // prime in a heap, it can improve the theoretical bound to O( log(k)N ),
    public int nthSuperUglyNumber3(int n, int[] primes) {
	// Write your code here
	if (primes == null || primes.length == 0 || n <= 0) {
	    return 0;
	}

	Queue<Long> Q = new PriorityQueue<Long>();
	HashSet<Long> inQ = new HashSet<Long>();
	Q.add(Long.valueOf(1));
	inQ.add(Long.valueOf(1));

	for (int i = 1; i < n; i++) {
	    Long curt = Q.poll();
	    for (int j = 0; j < primes.length; j++) {
		Long next = curt * primes[j];
		if (!inQ.contains(next)) {
		    Q.add(next);
		    inQ.add(next);
		}
	    }
	}

	return Q.peek().intValue();
    }

}
